<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Hibernate缓存机制</title>
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" href="/static/bootstrap/css/bootstrap.min.css">
        <!-- Custom CSS -->
        <link rel="stylesheet" href="/static/css/leo.css">
        <link rel="stylesheet" href="/static/css/prettify.css">

    </head>
    <body>
      <div class="leo-head">
        <ul class="leo-nav">
  
    <li><a class="leo-nav-item" href="/">首页</a></li>
  
    <li><a class="leo-nav-item" href="/category.html">归档</a></li>
  
    <li><a class="leo-nav-item" href="/andy.html">豆豆</a></li>
  
    <li><a class="leo-nav-item last" href="/contant.html">联系我</a></li>
  
</ul>

      </div>
          </div>
      <div class="container">
        <div class="row">
          <div class="col-md-8"><div class="leo-category"><h1 class="leo-articel-title">Hibernate缓存机制</h1>
<div class="post">
<h3><code>Hibernate</code>缓存说明</h3>

<p>&emsp;<code>Hibernate</code>在查询数据时，首先到缓存中去查找，如果找到就直接使用，找不到的时候就会从物理数据源中检索，
所以把频繁使用的数据加载到缓存区后，就可以大大减少应用程序对物理数据源的访问，使得程序的运行性能明显的提升。</p>

<h3><code>Hibernate</code>缓存分类</h3>

<h4>一级缓存</h4>

<p>&emsp;一级缓存也叫<code>session</code>级缓存或事务级缓存，一级缓存的生命周期和<code>Session</code>的生命周期一致，
也就是当 <code>session</code>关闭时缓存即被清除，一级缓存在<code>Hibernate</code>中是不可配置的，即不能被卸载。</p>

<h4>二级缓存</h4>

<p>&emsp;二级缓存也称进程级缓存或<code>SessionFactory</code>级缓存，二级缓存可以被所有的<code>session</code>共享，二级缓存的生命周期和<code>SessionFactory</code>的生命周期一致。<br>
&emsp;二级缓存在<code>Hibernate</code>中是可以配置的，可以通过<code>class-cache</code>配置类粒度级别的缓存(<code>class-cache</code>在<code>class</code>中数据发生任何变化的情况下自动更新)，同时也可通过<code>collection-cache</code>配置集合粒度级别的缓存(<code>collection-cache</code>仅在 <code>collection</code>中增加了元素或者删除了元素的情况下才自动更新，也就是当<code>collection</code>中元素发生值的变化的情况下它是不会自动更新的)。</p>

<h4>查询缓存</h4>

<p>&emsp;查询缓存，查询的结果集也可以被缓存。只有当经常使用同样的参数进行查询时，这才会有些用处。要使用查询缓存，
首先你必须打开它： <code>hibernate.cache.use_query_cache true</code>。该设置将会创建两个缓存区域 - 
一个用于保存查询结果集<code>(org.hibernate.cache.StandardQueryCache)</code>； 
另一个则用于保存最近查询的一系列表的时间戳<code>(org.hibernate.cache.UpdateTimestampsCache)</code>。<br>
&emsp;请注意：在查询缓存中，它并不缓存结果集中所包含的实体的确切状态；它只缓存这些实体的标识符属性的值、以及各值类型的结果。 
所以查询缓存通常会和二级缓存一起使用。绝大多数的查询并不能从查询缓存中受益，所以<code>Hibernate</code>默认是不进行查询缓存的。
如若需要进行缓存，请调用 <code>Query.setCacheable(true)</code>方法。这个调用会让查询在执行过程中时先从缓存中查找结果， 
并将自己的结果集放到缓存中去。 查询缓存在<code>Hibernate</code>同样是可配置的，默认是关闭的，查询缓存的配置：
在<code>hibernate.cfg.xml</code>文件中启用查询缓存，如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;property name=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt;
</code></pre></div>
<p>&emsp;在程序中必须手动启用查询缓存，如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">query.setCacheable(true);
</code></pre></div>
<p><strong>查询缓存是依赖二级缓存的</strong></p>

<h3>Session.load</h3>

<p>&emsp;在执行<code>session.load</code>时，<code>hibernate</code>认为该id对应的对象在数据库中一定存在。<code>load</code>方法在创建时首先会查询<code>session</code>，
看看该<code>id</code> 对应的对象是否存在，不存在则创建代理，实际用到该对象中的其他属性时才查询数据库，万一数据库中不存在该记录，才抛出异常。
<code>Load</code>方法抛出异常是指在使用该对象的数据时，而不是在创建该对象的数据时。<br>
<em>一级缓存的管理:</em><br>
&emsp;<code>evit(Object obj)</code>  将指定的持久化对象从一级缓存中清除,释放对象所占用的内存资源,指定对象从持久化状态变为脱管状态,从而成为游离对象;<br>
&emsp;<code>clear()</code>  将一级缓存中的所有持久化对象清除,释放其占用的内存资源<br>
&emsp;<code>contains(Object obj)</code> 判断指定的对象是否存在于一级缓存中.<br>
&emsp;<code>flush()</code> 刷新一级缓存区的内容,使之与数据库数据保持同步.<br>
&emsp;如何避免一次性大量实体数据入库导致内存溢出：先<code>flush</code>，然后<code>clear</code>    </p>

<p><em>二级缓存的管理:</em><br>
&emsp;<code>evict(Class arg0)</code>  将指定类的所有持久化对象从二级缓存中清除,释放其占用的内存资源.<br>
&emsp;<code>evict(Class arg0, Serializable arg1)</code>  将某个类的指定ID的持久化对象从二级缓存中清除,释放对象所占用的资源.<br>
&emsp;<code>evictCollection(String arg0)</code>  将指定类的所有持久化对象的指定集合从二级缓存中清除,释放其占用的内存资源.  </p>

<h3>Session.get</h3>

<p>&emsp;在执行<code>Session.get</code>时，<code>hibernate</code>会确认一下该<code>id</code>对应的数据是否存在。
  <code>get</code>方法首先在<code>session</code>缓存中查询，没有的话然后在二级缓存中查询，最后查询数据库。</p>

<h3>Query.list</h3>

<p>&emsp;在执行<code>Query.list</code>时，<code>Hibernate</code>的做法是首先检查是否配置了查询缓存，如配置了则从查询缓存中查找key为查询语句+查询参数+分页条件的值，
如获取不到则从数据库中进行获取，从数据库获取到后<code>Hibernate</code>将会相应的填充一级、二级和查询缓存，如获取到的为直接的结果集，则直接返回，
如获取到的为一堆<code>id</code>的值，则再根据<code>id</code>获取相应的值<code>(Session.load)</code>，最后形成结果集返回，可以看到，在这样的情况下，<code>list</code>也是有可能造成N次的查询的。
查询缓存在数据发生任何变化的情况下都会被自动的清空。</p>

<h3>Query.iterator</h3>

<p>&emsp;在执行<code>Query.iterator</code>时，和<code>Query.list</code>的不同的在于从数据库获取的处理上，<code>Query.iterator</code>向数据库发起的是 <code>select id from</code>这样的语句，也就是它是先获取符合查询条件的<code>id</code>，之后在进行<code>iterator.next</code>调用时才再次发起<code>session.load</code>的调用获取实际的数据。可见，在拥有二级缓存并且查询参数多变的情况下，<code>Query.iterator</code>会比<code>Query.list</code>更为高效。</p>

</div>
<p class="leo-protect">
  作者：
  <a href="/">leo</a>
  　发布时间：2013年12月06日
  <br>
  原文：
  <a href="/2013/12/06/Hibernate-cache-information">Hibernate缓存机制</a>
  <br>
  标签： Hibernate
  <br/>
  版权所有，转载时必须以链接形式注明作者和原出处并保留本声明。
  <br>
</p>
<script type="text/javascript" src="/static/js/jquery-1.8.3.min.js"></script>
<script type="text/javascript" src="/static/js/prettify.js"></script>
<script type="text/javascript">
  $(function(){
    $("pre").addClass("prettyprint linenums");
    prettyPrint();
  });
</script>

<!-- Duoshuo Comment BEGIN -->
  <div class="ds-thread"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"jutleo"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- Duoshuo Comment END --></div></div>
          <div class="col-md-4">
            <div class="list-group">
              <a href="#" class="list-group-item list-group-item-success disabled">分类</a>
              
              <a href="/db/"  class="list-group-item" title="查看所有此分类文章列表"><span class="badge">1</span>db </a>
              
              <a href="/server/"  class="list-group-item" title="查看所有此分类文章列表"><span class="badge">2</span>server </a>
              
              <a href="/office/"  class="list-group-item" title="查看所有此分类文章列表"><span class="badge">1</span>office </a>
              
              <a href="/javascript/"  class="list-group-item" title="查看所有此分类文章列表"><span class="badge">6</span>javascript </a>
              
              <a href="/ireport/"  class="list-group-item" title="查看所有此分类文章列表"><span class="badge">15</span>ireport </a>
              
              <a href="/blog/"  class="list-group-item" title="查看所有此分类文章列表"><span class="badge">1</span>blog </a>
              
              <a href="/orm/"  class="list-group-item" title="查看所有此分类文章列表"><span class="badge">2</span>orm </a>
              
              <a href="/technology/"  class="list-group-item" title="查看所有此分类文章列表"><span class="badge">1</span>technology </a>
              
              <a href="/life/"  class="list-group-item" title="查看所有此分类文章列表"><span class="badge">3</span>life </a>
              
              <a href="/spring/"  class="list-group-item" title="查看所有此分类文章列表"><span class="badge">5</span>spring </a>
              
            </div>
            <div class="leo-article-category">
              <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2975520964&verifier=eac976c7&dpc=1"></iframe>
            </div>

          </div>
      </div>

        </div>
        
      <div class="leo-foot">
        <p>
 Copyright &copy; 2010 - 2014 &nbsp;jutleo@gmail.com. 保留所有权利。
</p>
      </div>
    </body>
</html>
